---
templateKey: blog-post
title: How this website was built
description: Modern web development with GatsbyJS
date: 2020-05-06T00:00:00.000Z
is_hidden: false
featuredImage: /test.png
---
In 2020, any reasonably motivated individual with a sense of agency could set themselves up a nice looking, performant website over the weekend, thanks to the [rise of the no-code movement](https://medium.com/@rrhoover/the-rise-of-no-code-e733d7c0944d) and with it, the proliferation of tools which allows people to make websites with virtually no code involved. Indeed, solutions like **Wix** and **Squarespace** abstracts away all the laborious HTML/CSS/JS work which power every website under the hood, and promises a hassle-free web development experience, allowing users to set up modern-looking websites in minutes. 

### A give and take

As wonderful as these tools are, they have a catch: by design, they offer limited ability for customization. Although some of the tools allow users to extend the basic templates they offer by manually entering CSS and JS snippets, they don't come close to the flexibility offered by custom-made solutions. This makes perfect sense, because the target customers for these tools are layment looking to quickly boostrap a personal site/blog, not programmers. There's a reason why web development is still in demand (and rapidly evolving still!) in 2020.

## The challenge

Obviously, being a computer science major, I couldn't possibly stoop to the lows of using **Wix**. Besides, I was fairly comfortable with the technical aspects of web development (having worked on making a website for a certain non-profit in Singapore back in 2016) and wanted to explore how this space had evolved since then. After some research, I learnt that static websites — serving static HTML files for faster loading speeds — were back in vogue, quite possibly underscoring the increased importance of delivering reliable, speedy experiences especially for critical web services, with corresponding significance placed on performance metrics such as [FMP (First meaningful paint)](https://developers.google.com/web/tools/lighthouse/audits/first-meaningful-paint) and [TTI (Time to Interactive)](https://developers.google.com/web/tools/lighthouse/audits/time-to-interactive). Around this time, I came across [GatsbyJS](https://www.gatsbyjs.org/), a framework built on React and GraphQL which generates static HTML files based on your React application[^1], enabling fast page loads while offering the attendant SEO benefits of statically rendered web pages. This seemed like a perfect fit for a relatively simple blog/portfolio website that I wanted to create, so I decided to go with GatsbyJS (having working knowledge in React also helped).

## A high-level overview

First off, if anyone reading this wants to give Gatsby a shot, you should probably consult Gatsby's [tutorial](https://www.gatsbyjs.org/tutorial/) first, and go through the whole thing. It's very well structured so completing the tutorial should give you a cursory knowledge of the framework — enough to get you started (though a knowledge of JS should precede this step). This section is not meant as an introduction to Gatsby (or React for that matter), but rather it aims to give a general overview of how this site (a Gatsby app) was structured. You can check out the source code for the website [here](https://github.com/sarckk/personal-site).

### Static Pages

The neat thing about Gatsby is that each **<name_of_file>.js** file placed in the `/src/pages` directory will automatically be converted (during build time) to the HTML file to be sent to the user when he visits the path with the name <name_of_file>. So for example, `about.js` will be served when the user visits the path **/about**.

```bash
├── 404.js
├── about.js
├── blog.js
├── books.js
├── index.js
└── work.js
```

Above is the actual directory structure for the pages on my website. Note that `index.js` is the special file which is served when the user visits the root directory (in my case, [yonghoonshin.com](https://www.yonghoonshin.com)). 

Each of these javascript files exports a React component, each responsible for rendering that particular page. 

### Dynamic Pages

Manually placing **.js** files in `/src/pages` works fine for static pages for which we can predetermine the content, but what if we want to dynamically create pages? This would be helpful, if not downright necessary, for personal blogs like this, since no sane person would like to create a React component for each time a new blog post is to be added. Instead, what we probably want is a more streamlined workflow in which we simply add [markdown](https://daringfireball.net/projects/markdown/syntax#overview) files to a directory like `/content/blog` and have them automatically be converted to pages during build time. In fact, this is what my website is doing behind the scenes.[^2] 

#### Gatsby Source Plugins
To achieve this, I had to download `gatsby-source-filesystem`, a source plugin whose job is essentially to look for files at the specified path and convert those to GraphQL nodes which can then be queried and passed into our React components.[^3] The specifics of what GraphQL entails is outside the scope of this post, but it is essential a **query language** much like traditional SQL which allows for fetching of data. The important thing to know is that Gatsby's data layer is built on top of GraphQL and its capabilities. 

```javascript
   {
      resolve: `gatsby-source-filesystem`,
      options: {
        name: "images",
        path: `${__dirname}/content/assets`,
      },
    },
    {
      resolve: `gatsby-source-filesystem`,
      options: {
        name: `blog`,
        path: `${__dirname}/content/blog`,
      },
    },
    {
      resolve: `gatsby-source-filesystem`,
      options: {
        name: `books`,
        path: `${__dirname}/content/books`,
      },
    },
```
In `gatsby-config.js`, I am sourcing nodes from three separate directories, one for the image assets used in blog posts (to be transformed by `gatsby-transformer-sharp`), two for markdown files in the **blogs** and **books** collections.

### Gatsby Transformer Plugins
After sourcing the markdown files, they are available as generic ** file nodes** in the GraphQL layer. However, to be rendered as blog posts, I need a way to convert them to **markdown nodes**. Here is the relevant part in `gatsby-config.js`:

```javascript
    {
      resolve: `gatsby-plugin-mdx`,
      options: {
        extensions: [`.mdx`, `.md`],
        plugins: [
          `gatsby-remark-relative-images`,
          `gatsby-remark-images`,
          `gatsby-remark-prismjs`,
        ],
        gatsbyRemarkPlugins: [
          `gatsby-remark-relative-images`,
          {
            resolve: `gatsby-remark-images`,
            options: {
              maxWidth: 1920,
            },
          },
          {
            resolve: `gatsby-remark-prismjs`,
            options: {
              aliases: { sh: "bash", js: "javascript" },
            },
          },
        ],
      },
    },
```
A few things to note here:

1. I'm using MDX instead of Markdown (they have the file extension .mdx)
2. I'm including 3 plugins along with `gatsby-plugin-mdx`. `gatsby-remark-images` converts the image links in .mdx files to image nodes to be processed by `gatsby-transformer-sharp` and consumed by `gatsby-image` to create images which are lazy-loaded and "blurred" into view. `gatsby-remark-relative-images` is a small plugin which automatically converts image sources generated by [NetlifyCMS](https://www.netlifycms.org/) to be relative to the node's parent directory.[^4] This has to be placed before `gatsby-remark-images` for Gatsby to play nice with NetlifyCMS. Lastly, I'm using `gatsby-remark-prismjs` which inserts pretty styling for code blocks which you are seeing on this very page.
3. A small annoyance, but I'm specifying the plugins under both **plugins** and **gatsbyRemarkPlugins** fields rather redundantly because it magically fails to work without it. This is a known issue with `gatsby-plugin-mdx`.

### Consuming nodes in Gatsby Node API
Once we have sourced and transformed the appropriate Mdx nodes, they become available via a GraphQL query. Using this and [Gatsby's Node API](https://www.gatsbyjs.org/docs/node-apis/), we can dynamically create pages based our MDX files. 

```javascript
exports.onCreateNode = async ({
  node,
  getNode,
  actions,
  store,
  cache,
  createNodeId,
}) => {
  const { createNodeField, createNode } = actions
  fmImagesToRelative(node)

  if (node.internal.type === `Mdx`) {
    const parentNode = getNode(node.parent)
    const collection =
      parentNode.name === "dummy" ? "dummy" : parentNode.sourceInstanceName

    createNodeField({
      node,
      name: `collection`,
      value: collection,
    })

    const slug = createFilePath({ node, getNode, basePath: "content" })
    const pathName = `${collection}${slug}`

    createNodeField({
      node,
      name: `pathName`,
      value: pathName,
    })

    if (parentNode.sourceInstanceName === "books") {
      const isbn = node.frontmatter.isbn
      const url = `http://covers.openlibrary.org/b/isbn/${isbn}-L.jpg`

      let fileNode = await createRemoteFileNode({
        url,
        parentNode: node.id,
        createNode,
        createNodeId,
        cache,
        store,
      })

      if (fileNode) {
        node.coverImg___NODE = fileNode.id
      }
    }
  }
}
```

Quite a mouthful to digest here, but the code is relatively simple. Using the `onCreateNode` API, we can define what action to perform when Gatsby reaches the stage of creating nodes during build time. The above code essentially checks if the node being created is of type `Mdx` and does a few things (in order):

1. Identifies the name of the collection which the node belongs to. These can be **blog**, **books** or **dummy**. Dummy content is needed because GraphQL throws an invalid query error if we try to query MDX files which don't exist (since they can't be inferred). It then adds a custom *collection* field to the Mdx node using the `createNodeField` method.
2. Similarly, it adds *pathname* field to the Mdx node so that we can fetch it in components later and pass them to links.
3. If the Mdx node belongs to the collection **books** (for my book reviews), it retrieves the ISBN field from the file's frontmatter, generates the link to the [Open Library Book Covers API](https://openlibrary.org/dev/docs/api/covers) and creates a remote file node using `createRemoteFileNode`. This is needed so that external images can be sourced as nodes for `gatsby-image` to do its magic. Just follow Gatsby's [advice](https://www.gatsbyjs.org/docs/preprocessing-external-images/).



[^1]: It's actually cooler than that: Gatsby also performs a process called [hydration](https://www.gatsbyjs.org/docs/react-hydration/) which converts the static HTML files, once they've been served, to a full-fledge React application so that client-side JS can then manipulate the DOM further.
[^2]: Except instead of plain markdown, I'm using [MDX](https://mdxjs.com/), which allows me to insert JSX in markdown.
[^3]: GraphQL, just like React, was developed by Facebook.
[^4]: At this time, however, images in the post body cannot be handled by this plugin due to an error for which the PR fix hasn't been accepted yet. See my [commit log](https://github.com/sarckk/personal-site/commit/8b6cbf5647f4652dccb1eccd0bb5c08301ca5daa) for more info.