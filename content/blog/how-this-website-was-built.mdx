---
templateKey: blog-post
title: How this website was built
description: Modern web development with GatsbyJS
date: 2020-05-06T00:00:00.000Z
is_hidden: false
featuredImage: /test.png
---
In 2020, any reasonably motivated individual with a sense of agency could set themselves up a nice looking, performant website over the weekend, thanks to the [rise of the no-code movement](https://medium.com/@rrhoover/the-rise-of-no-code-e733d7c0944d) and with it, the proliferation of tools which allows people to make websites with virtually no code involved. Indeed, solutions like **Wix** and **Squarespace** abstracts away all the laborious HTML/CSS/JS work which power every website under the hood, and promises a hassle-free web development experience, allowing users to set up modern-looking websites in minutes. 

### A give and take

As wonderful as these tools are, they have a catch: by design, they offer limited ability for customization. Although some of the tools allow users to extend the basic templates they offer by manually entering CSS and JS snippets, they don't come close to the flexibility offered by custom-made solutions. This makes perfect sense, because the target customers for these tools are layment looking to quickly boostrap a personal site/blog, not programmers. There's a reason why web development is still in demand (and rapidly evolving still!) in 2020.

## The challenge

Obviously, being a computer science major, I couldn't possibly stoop to the lows of using **Wix**. Besides, I was fairly comfortable with the technical aspects of web development (having worked on making a website for a certain non-profit in Singapore back in 2016) and wanted to explore how this space had evolved since then. After some research, I learnt that static websites — serving static HTML files for faster loading speeds — were back in vogue, quite possibly underscoring the increased importance of delivering reliable, speedy experiences especially for critical web services, with corresponding significance placed on performance metrics such as [FMP (First meaningful paint)](https://developers.google.com/web/tools/lighthouse/audits/first-meaningful-paint) and [TTI (Time to Interactive)](https://developers.google.com/web/tools/lighthouse/audits/time-to-interactive). Around this time, I came across [GatsbyJS](https://www.gatsbyjs.org/), a framework built on React and GraphQL which generates static HTML files based on your React application[^1], enabling fast page loads while offering the attendant SEO benefits of statically rendered web pages. This seemed like a perfect fit for a relatively simple blog/portfolio website that I wanted to create, so I decided to go with GatsbyJS (having working knowledge in React also helped).

## A high-level overview

First off, if anyone reading this wants to give Gatsby a shot, you should probably consult Gatsby's [tutorial](https://www.gatsbyjs.org/tutorial/) first, and go through the whole thing. It's very well structured so completing the tutorial should give you a cursory knowledge of the framework — enough to get you started (though a knowledge of JS should precede this step). This section is not meant as an introduction to Gatsby (or React for that matter), but rather it aims to give a general overview of how this site (a Gatsby app) was structured. You can check out the source code for the website [here](https://github.com/sarckk/personal-site).

### Static Pages

The neat thing about Gatsby is that each **<name_of_file>.js** file placed in the `/src/pages` directory will automatically be converted (during build time) to the HTML file to be sent to the user when he visits the path with the name <name_of_file>. So for example, `about.js` will be served when the user visits the path **/about**.

```bash
├── 404.js
├── about.js
├── blog.js
├── books.js
├── index.js
└── work.js
```

Above is the actual directory structure for the pages on my website. Note that `index.js` is the special file which is served when the user visits the root directory (in my case, [yonghoonshin.com](https://www.yonghoonshin.com)). 

Each of these javascript files exports a React component, each responsible for rendering that particular page. 

### Dynamic Pages

Manually placing **.js** files in `/src/pages` works fine for static pages for which we can predetermine the content, but what if we want to dynamically create pages? This would be helpful, if not downright necessary, for personal blogs like this, since no sane person would like to create a React component for each time a new blog post is to be added. Instead, what we probably want is a more streamlined workflow in which we simply add [markdown](https://daringfireball.net/projects/markdown/syntax#overview) files to a directory like `/content/blog` and have them automatically be converted to pages during build time. In fact, this is what my website is doing behind the scenes.[^2] 

#### Gatsby Source Plugins
To achieve this, I had to download `gatsby-source-filesystem`, a source plugin whose job is essentially to look for files at the specified path and convert those to GraphQL nodes which can then be queried and passed into our React components.[^3] The specifics of what GraphQL entails is outside the scope of this post, but it is essential a **query language** much like traditional SQL which allows for fetching of data. The important thing to know is that Gatsby's data layer is built on top of GraphQL and its capabilities. 

```javascript
   {
      resolve: `gatsby-source-filesystem`,
      options: {
        name: "images",
        path: `${__dirname}/content/assets`,
      },
    },
    {
      resolve: `gatsby-source-filesystem`,
      options: {
        name: `blog`,
        path: `${__dirname}/content/blog`,
      },
    },
    {
      resolve: `gatsby-source-filesystem`,
      options: {
        name: `books`,
        path: `${__dirname}/content/books`,
      },
    },
```
In `gatsby-config.js`, I am sourcing nodes from three separate directories, one for the image assets used in blog posts (to be transformed by `gatsby-transformer-sharp`), two for MDX files in the **blogs** and **books** collections.

### Gatsby Transformer Plugins
After sourcing the MDX files, they are available as file nodes in the GraphQL layer. However, to be rendered as blog posts, I need a way to convert them to **Mdx** nodes. Here is the relevant part in `gatsby-config.js`:

```javascript
    {
      resolve: `gatsby-plugin-mdx`,
      options: {
        extensions: [`.mdx`, `.md`],
        plugins: [
          `gatsby-remark-relative-images`,
          `gatsby-remark-images`,
          `gatsby-remark-prismjs`,
        ],
        gatsbyRemarkPlugins: [
          `gatsby-remark-relative-images`,
          {
            resolve: `gatsby-remark-images`,
            options: {
              maxWidth: 1920,
            },
          },
          {
            resolve: `gatsby-remark-prismjs`,
            options: {
              aliases: { sh: "bash", js: "javascript" },
            },
          },
        ],
      },
    },
```
A few things to note here:
 - 

[^1]: It's actually cooler than that: Gatsby also performs a process called [hydration](https://www.gatsbyjs.org/docs/react-hydration/) which converts the static HTML files, once they've been served, to a full-fledge React application so that client-side JS can then manipulate the DOM further.
[^2]: Except instead of plain markdown, I'm using [MDX](https://mdxjs.com/), which allows me to insert JSX in markdown.
[^3]: GraphQL, just like React, was developed by Facebook.